# TELJES CTRADER PLUGIN PROJEKT - EGYETLEN FÁJL

Másold ki az egészet, majd szedd szét a `// ===== FILE:` jelzések mentén.

---

```cpp
// ============================================================================
// ===== FILE: include/globals.h =====
// ============================================================================
#pragma once

#define WIN32_LEAN_AND_MEAN
#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <winhttp.h>
#include <oleauto.h>
#include <process.h>
#include <shellapi.h>
#include <string>
#include <map>
#include <vector>
#include <cmath>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "winhttp.lib")

#define DLLFUNC extern "C" __declspec(dllexport)

extern int(__cdecl* BrokerMessage)(const char* Text);
extern int(__cdecl* BrokerProgress)(intptr_t Progress);

enum class CtraderEnv { Demo, Live };

struct Trade {
    int zorroId;
    long long ctid;
    std::string symbol;
    int amount;
    double openPrice;
    double closePrice;
    long long openTime;
    long long closeTime;
    double profit;
    double commission;
    double swap;
    bool closed;
};

struct CsvCreds {
    std::string clientId;
    std::string clientSecret;
    std::string type;
    std::string accountId;
    std::string accessToken;
};

struct GLOBAL {
    char Token[2048];
    char RefreshToken[2048];
    int Diag;
    long long CTraderAccountId;
    CtraderEnv Env;
    char ClientId[256];
    char ClientSecret[256];
    char RedirectUri[512];
    char Scope[128];
    char Product[64];
    bool HasLogin;
    
    HANDLE hNetworkThread;
    bool bIsRunning;
    
    CRITICAL_SECTION cs_trades;
    CRITICAL_SECTION cs_log;
    
    HWND hWnd;
    char DllPath[MAX_PATH];
    char LogPath[MAX_PATH];
    
    std::map<std::string, int> pendingTrades;
    std::map<int, Trade> openTrades;
    std::map<long long, int> ctidToZorroId;
    std::map<int, std::pair<std::string, int>> pendingTradeInfo;
    int nextTradeId;
    
    ULONGLONG lastPingMs;
    ULONGLONG lastRetryProcessMs;
};

extern GLOBAL G;

constexpr int PLUGIN_TYPE = 2;
constexpr const char* PLUGIN_NAME = "cTrader";
constexpr const char* PLUGIN_VERSION = "1.2.1";
constexpr const char* CTRADER_HOST_DEMO = "demo.ctraderapi.com";
constexpr const char* CTRADER_HOST_LIVE = "live.ctraderapi.com";
constexpr const int CTRADER_WS_PORT = 5036;
constexpr ULONGLONG PING_INTERVAL_MS = 30000;

typedef double DATE;


// ============================================================================
// ===== FILE: include/utils.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace Utils {
    void ShowMsg(const char* text, const char* detail = "");
    void LogToFile(const char* type, const char* message);
    const char* GetMsgId();
    bool BodyIndicatesError(const char* buffer);
    bool StrContainsCaseInsensitive(const char* haystack, const char* needle);
}


// ============================================================================
// ===== FILE: include/network.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace Network {
    bool Connect(const char* host, const char* port);
    void Disconnect();
    bool Send(const char* data);
    int Receive(char* buffer, int bufferSize);
    bool IsConnected();
}


// ============================================================================
// ===== FILE: include/auth.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace Auth {
    bool LoadTokenFromDisk();
    bool SaveTokenToDisk(const std::string& access, const std::string& refresh);
    bool ParseJsonTokenFields(const std::string& body, std::string& access, std::string& refresh);
    
    bool RefreshAccessToken();
    bool FetchAccountsList(std::vector<long long>& accountIds);
    
    bool WinHttpGetToken(const std::wstring& host, const std::wstring& path,
                        const std::map<std::string, std::string>& params,
                        std::string& outBody);
}


// ============================================================================
// ===== FILE: include/oauth_utils.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace OAuth {
    bool PerformInteractiveFlow();
    bool ListenForCode(std::string& outCode, int port = 53123, DWORD timeoutMs = 60000);
    bool ExchangeCodeForTokens(const std::string& code, std::string& accessOut, std::string& refreshOut);
}


// ============================================================================
// ===== FILE: include/reconnect.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace Reconnect {
    bool AuthenticateAfterConnect();
    void ResubscribeSymbols();
    bool Attempt(int maxRetries = 3);
}


// ============================================================================
// ===== FILE: include/csv_loader.h =====
// ============================================================================
#pragma once
#include "globals.h"

namespace CsvLoader {
    bool LoadAccountsCsv(CsvCreds& out, const char* hintAccountOrUser, const char* typeHint);
}


// ============================================================================
// ===== FILE: include/symbols.h =====
// ============================================================================
#pragma once
#include <string>
#include <cstdint>

struct SymbolInfo {
    long long id;
    int digits;
    bool subscribed;
    long long bid;
    long long ask;
    int64_t retry_count;
    int64_t last_retry_time;
};

namespace Symbols {
    void Initialize();
    void Cleanup();
    void AddSymbol(const std::string& name, long long id, int digits);
    bool EnsureSubscribed(long long ctidTraderAccountId, const std::string& symbolName);
    void UpdateQuote(long long symbolId, long long bid, long long ask);
    void BatchResubscribe(long long ctidTraderAccountId);
    SymbolInfo* GetSymbol(const std::string& symbolName);
    void HandleSubscriptionResponse(const std::string& clientMsgId, bool success, const std::string& error_details);
    void ProcessRetries(long long ctidTraderAccountId);
    void GenerateBrokerAssetsFile(const char* dllPath);
    void Lock();
    void Unlock();
}


// ============================================================================
// ===== FILE: src/utils.cpp =====
// ============================================================================
#include "utils.h"
#include <ctime>
#include <fstream>
#include <algorithm>

namespace Utils {

void ShowMsg(const char* text, const char* detail) {
    static char msg[4096];
    if (detail && *detail) {
        sprintf_s(msg, "%s %s", text, detail);
    } else {
        strcpy_s(msg, sizeof(msg), text);
    }
    
    LogToFile("MESSAGE", msg);
    if (BrokerMessage) BrokerMessage(msg);
}

void LogToFile(const char* type, const char* message) {
    if (!type || !message) return;
    
    EnterCriticalSection(&G.cs_log);
    
    char path[MAX_PATH];
    sprintf_s(path, "%swesocket.txt", G.DllPath);
    
    FILE* f = nullptr;
    if (fopen_s(&f, path, "a") == 0 && f) {
        time_t t = time(nullptr);
        struct tm tmv;
        localtime_s(&tmv, &t);
        char ts[64];
        strftime(ts, sizeof(ts), "%Y-%m-%d %H:%M:%S", &tmv);
        fprintf(f, "[%s] %s: %s\n", ts, type, message);
        fclose(f);
    }
    
    LeaveCriticalSection(&G.cs_log);
}

const char* GetMsgId() {
    static int id = 0;
    static char buffer[32];
    sprintf_s(buffer, "msg_%d", ++id);
    return buffer;
}

bool BodyIndicatesError(const char* buffer) {
    if (!buffer || strlen(buffer) == 0) return true;
    if (strstr(buffer, "\"errorCode\"")) return true;
    if (strstr(buffer, "\"error\":")) return true;
    if (strstr(buffer, "FAILURE")) return true;
    return false;
}

bool StrContainsCaseInsensitive(const char* haystack, const char* needle) {
    if (!haystack || !needle) return false;
    std::string h(haystack), n(needle);
    std::transform(h.begin(), h.end(), h.begin(), ::tolower);
    std::transform(n.begin(), n.end(), n.begin(), ::tolower);
    return h.find(n) != std::string::npos;
}

}


// ============================================================================
// ===== FILE: src/network.cpp =====
// ============================================================================
#include "network.h"
#include "utils.h"

namespace {
    SOCKET g_socket = INVALID_SOCKET;
}

namespace Network {

bool Connect(const char* host, const char* port) {
    if (g_socket != INVALID_SOCKET) {
        closesocket(g_socket);
        g_socket = INVALID_SOCKET;
    }
    
    struct addrinfo hints = {0}, *result = nullptr;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    
    if (getaddrinfo(host, port, &hints, &result) != 0) {
        char msg[256];
        sprintf_s(msg, "DNS lookup failed: %s", host);
        Utils::ShowMsg(msg);
        return false;
    }
    
    g_socket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (g_socket == INVALID_SOCKET) {
        freeaddrinfo(result);
        Utils::ShowMsg("Socket creation failed");
        return false;
    }
    
    DWORD timeout = 30000;
    setsockopt(g_socket, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
    setsockopt(g_socket, SOL_SOCKET, SO_SNDTIMEO, (char*)&timeout, sizeof(timeout));
    
    if (connect(g_socket, result->ai_addr, (int)result->ai_addrlen) == SOCKET_ERROR) {
        closesocket(g_socket);
        g_socket = INVALID_SOCKET;
        freeaddrinfo(result);
        Utils::ShowMsg("Connection failed");
        return false;
    }
    
    freeaddrinfo(result);
    
    u_long mode = 1;
    ioctlsocket(g_socket, FIONBIO, &mode);
    
    char msg[256];
    sprintf_s(msg, "Connected: %s:%s", host, port);
    Utils::LogToFile("TCP_CONNECT", msg);
    
    return true;
}

void Disconnect() {
    if (g_socket != INVALID_SOCKET) {
        shutdown(g_socket, SD_BOTH);
        closesocket(g_socket);
        g_socket = INVALID_SOCKET;
        Utils::LogToFile("TCP_DISCONNECT", "Closed");
    }
}

bool Send(const char* data) {
    if (g_socket == INVALID_SOCKET || !data) return false;
    
    int len = (int)strlen(data);
    int total = 0;
    
    while (total < len) {
        int sent = send(g_socket, data + total, len - total, 0);
        if (sent == SOCKET_ERROR) {
            if (WSAGetLastError() == WSAEWOULDBLOCK) {
                Sleep(10);
                continue;
            }
            return false;
        }
        total += sent;
    }
    
    Utils::LogToFile("TCP_SEND", data);
    return true;
}

int Receive(char* buffer, int bufferSize) {
    if (g_socket == INVALID_SOCKET || !buffer || bufferSize <= 0) return -1;
    
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(g_socket, &readfds);
    
    struct timeval timeout;
    timeout.tv_sec = 0;
    timeout.tv_usec = 100000;
    
    int sel = select(0, &readfds, nullptr, nullptr, &timeout);
    if (sel == SOCKET_ERROR) return -1;
    if (sel == 0) return 0;
    
    int received = recv(g_socket, buffer, bufferSize - 1, 0);
    if (received == SOCKET_ERROR) {
        if (WSAGetLastError() == WSAEWOULDBLOCK) return 0;
        return -1;
    }
    if (received == 0) return -1;
    
    buffer[received] = '\0';
    return received;
}

bool IsConnected() {
    return g_socket != INVALID_SOCKET;
}

}


// ============================================================================
// ===== FILE: src/auth.cpp =====
// ============================================================================
#include "auth.h"
#include "network.h"
#include "utils.h"
#include <sstream>
#include <fstream>

namespace Auth {

bool ParseJsonTokenFields(const std::string& body, std::string& access, std::string& refresh) {
    access.clear();
    refresh.clear();
    
    auto extract = [&](const char* key)->std::string {
        size_t p = body.find(key);
        if (p == std::string::npos) return {};
        
        size_t colon = body.find(':', p + strlen(key));
        if (colon == std::string::npos) return {};
        
        size_t q = colon + 1;
        while (q < body.size() && (body[q] == ' ' || body[q] == '\t')) ++q;
        if (q >= body.size() || body[q] != '"') return {};
        
        size_t start = q + 1;
        size_t end = body.find('"', start);
        if (end == std::string::npos) return {};
        
        return body.substr(start, end - start);
    };
    
    access = extract("\"access_token\"");
    if (access.empty()) access = extract("\"accessToken\"");
    
    refresh = extract("\"refresh_token\"");
    if (refresh.empty()) refresh = extract("\"refreshToken\"");
    
    return !access.empty();
}

bool LoadTokenFromDisk() {
    char path[MAX_PATH];
    sprintf_s(path, "%soauth_token.json", G.DllPath);
    
    std::ifstream file(path);
    if (!file.is_open()) return false;
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    file.close();
    
    std::string content = buffer.str();
    if (content.empty()) return false;
    
    std::string token, refresh;
    if (!ParseJsonTokenFields(content, token, refresh)) return false;
    if (token.empty()) return false;
    
    strncpy_s(G.Token, sizeof(G.Token), token.c_str(), _TRUNCATE);
    if (!refresh.empty()) {
        strncpy_s(G.RefreshToken, sizeof(G.RefreshToken), refresh.c_str(), _TRUNCATE);
    }
    
    return true;
}

bool SaveTokenToDisk(const std::string& access, const std::string& refresh) {
    char path[MAX_PATH];
    sprintf_s(path, "%soauth_token.json", G.DllPath);
    
    std::ofstream file(path);
    if (!file.is_open()) return false;
    
    file << "{\n";
    file << "  \"access_token\": \"" << access << "\",\n";
    file << "  \"refresh_token\": \"" << refresh << "\"\n";
    file << "}\n";
    file.close();
    
    return true;
}

bool WinHttpGetToken(const std::wstring& host, const std::wstring& path,
                    const std::map<std::string, std::string>& params,
                    std::string& outBody) {
    outBody.clear();
    
    std::wstring fullPath = path;
    bool first = true;
    
    for (const auto& param : params) {
        if (first) {
            fullPath += L"?";
            first = false;
        } else {
            fullPath += L"&";
        }
        
        std::wstring key(param.first.begin(), param.first.end());
        std::wstring value(param.second.begin(), param.second.end());
        fullPath += key + L"=" + value;
    }
    
    HINTERNET hSession = WinHttpOpen(L"cTrader-Zorro/1.2.1",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);
    if (!hSession) return false;
    
    HINTERNET hConnect = WinHttpConnect(hSession, host.c_str(),
        INTERNET_DEFAULT_HTTPS_PORT, 0);
    if (!hConnect) {
        WinHttpCloseHandle(hSession);
        return false;
    }
    
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", fullPath.c_str(),
        nullptr, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES,
        WINHTTP_FLAG_SECURE);
    if (!hRequest) {
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return false;
    }
    
    BOOL result = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS,
        0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
    if (!result) {
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return false;
    }
    
    result = WinHttpReceiveResponse(hRequest, nullptr);
    if (!result) {
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);
        return false;
    }
    
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    
    do {
        dwSize = 0;
        if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) break;
        if (dwSize == 0) break;
        
        char* buffer = new char[dwSize + 1];
        ZeroMemory(buffer, dwSize + 1);
        
        if (WinHttpReadData(hRequest, buffer, dwSize, &dwDownloaded)) {
            outBody.append(buffer, dwDownloaded);
        }
        delete[] buffer;
    } while (dwSize > 0);
    
    WinHttpCloseHandle(hRequest);
    WinHttpCloseHandle(hConnect);
    WinHttpCloseHandle(hSession);
    
    return !outBody.empty();
}

bool RefreshAccessToken() {
    if (!G.RefreshToken[0]) {
        Utils::ShowMsg("No refresh token");
        return false;
    }
    
    Utils::ShowMsg("Refreshing token...");
    
    std::map<std::string, std::string> params;
    params["grant_type"] = "refresh_token";
    params["refresh_token"] = G.RefreshToken;
    params["client_id"] = G.ClientId;
    params["client_secret"] = G.ClientSecret;
    
    std::string responseBody;
    if (!WinHttpGetToken(L"openapi.ctrader.com", L"/apps/token", params, responseBody)) {
        Utils::ShowMsg("Token refresh failed");
        return false;
    }
    
    std::string newAccess, newRefresh;
    if (!ParseJsonTokenFields(responseBody, newAccess, newRefresh)) {
        Utils::ShowMsg("Parse failed");
        Utils::LogToFile("TOKEN_REFRESH_FAIL", responseBody.c_str());
        return false;
    }
    
    if (newAccess.empty()) return false;
    
    strncpy_s(G.Token, sizeof(G.Token), newAccess.c_str(), _TRUNCATE);
    if (!newRefresh.empty()) {
        strncpy_s(G.RefreshToken, sizeof(G.RefreshToken), newRefresh.c_str(), _TRUNCATE);
    }
    
    SaveTokenToDisk(newAccess, newRefresh);
    Utils::ShowMsg("Token refreshed");
    return true;
}

bool FetchAccountsList(std::vector<long long>& accountIds) {
    char request[1024];
    sprintf_s(request,
        "{\"clientMsgId\":\"%s\",\"payloadType\":2119,\"payload\":{\"accessToken\":\"%s\"}}",
        Utils::GetMsgId(), G.Token);
    
    char response[16384] = {0};
    if (!Network::Send(request) || Network::Receive(response, sizeof(response)) <= 0) {
        Utils::ShowMsg("Accounts fetch failed");
        return false;
    }
    
    Utils::LogToFile("ACCOUNTS_RESPONSE", response);
    
    if (Utils::BodyIndicatesError(response)) return false;
    if (!strstr(response, "\"payloadType\":2120")) return false;
    
    const char* current = response;
    while ((current = strstr(current, "\"ctidTraderAccountId\":"))) {
        long long aid = 0;
        if (sscanf_s(current, "\"ctidTraderAccountId\":%lld", &aid) == 1 && aid > 0) {
            bool dup = false;
            for (size_t i = 0; i < accountIds.size(); ++i) {
                if (accountIds[i] == aid) {
                    dup = true;
                    break;
                }
            }
            if (!dup) accountIds.push_back(aid);
        }
        current += 21;
    }
    
    return !accountIds.empty();
}

}


// ============================================================================
// ===== FILE: src/oauth_utils.cpp =====
// ============================================================================
#include "oauth_utils.h"
#include "auth.h"
#include "utils.h"
#include <sstream>

namespace OAuth {

bool ListenForCode(std::string& outCode, int port, DWORD timeoutMs) {
    outCode.clear();
    
    SOCKET listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listenSocket == INVALID_SOCKET) {
        Utils::ShowMsg("Failed to create listen socket");
        return false;
    }
    
    sockaddr_in service;
    service.sin_family = AF_INET;
    service.sin_addr.s_addr = inet_addr("127.0.0.1");
    service.sin_port = htons((u_short)port);
    
    if (bind(listenSocket, (SOCKADDR*)&service, sizeof(service)) == SOCKET_ERROR) {
        closesocket(listenSocket);
        Utils::ShowMsg("Failed to bind to port 53123");
        return false;
    }
    
    if (listen(listenSocket, 1) == SOCKET_ERROR) {
        closesocket(listenSocket);
        Utils::ShowMsg("Failed to listen");
        return false;
    }
    
    DWORD timeout = timeoutMs;
    setsockopt(listenSocket, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
    
    Utils::ShowMsg("Waiting for OAuth callback...");
    
    SOCKET acceptSocket = accept(listenSocket, NULL, NULL);
    if (acceptSocket == INVALID_SOCKET) {
        closesocket(listenSocket);
        Utils::ShowMsg("Timeout waiting for callback");
        return false;
    }
    
    char buffer[4096] = {0};
    int bytesReceived = recv(acceptSocket, buffer, sizeof(buffer) - 1, 0);
    
    if (bytesReceived > 0) {
        buffer[bytesReceived] = '\0';
        
        const char* pCode = strstr(buffer, "code=");
        if (pCode) {
            pCode += 5;
            const char* pEnd = strstr(pCode, "&");
            if (!pEnd) pEnd = strstr(pCode, " ");
            if (!pEnd) pEnd = strstr(pCode, "\r");
            if (!pEnd) pEnd = strstr(pCode, "\n");
            
            if (pEnd) {
                outCode = std::string(pCode, pEnd - pCode);
            } else {
                outCode = std::string(pCode);
            }
        }
        
        const char* response = 
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html\r\n"
            "Connection: close\r\n"
            "\r\n"
            "<html><body>"
            "<h1>Authorization Successful!</h1>"
            "<p>You can close this window.</p>"
            "</body></html>";
        
        send(acceptSocket, response, (int)strlen(response), 0);
    }
    
    closesocket(acceptSocket);
    closesocket(listenSocket);
    
    return !outCode.empty();
}

bool ExchangeCodeForTokens(const std::string& code, std::string& accessOut, std::string& refreshOut) {
    std::map<std::string, std::string> params;
    params["grant_type"] = "authorization_code";
    params["code"] = code;
    params["redirect_uri"] = "http://127.0.0.1:53123/callback";
    params["client_id"] = G.ClientId;
    params["client_secret"] = G.ClientSecret;
    
    std::string responseBody;
    if (!Auth::WinHttpGetToken(L"openapi.ctrader.com", L"/apps/token", params, responseBody)) {
        Utils::ShowMsg("Token exchange failed");
        return false;
    }
    
    if (!Auth::ParseJsonTokenFields(responseBody, accessOut, refreshOut)) {
        Utils::ShowMsg("Parse failed");
        return false;
    }
    
    return !accessOut.empty();
}

bool PerformInteractiveFlow() {
    Utils::ShowMsg("=== OAuth2 Flow ===");
    
    std::ostringstream urlStream;
    urlStream << "https://openapi.ctrader.com/apps/auth";
    urlStream << "?client_id=" << G.ClientId;
    urlStream << "&redirect_uri=http://127.0.0.1:53123/callback";
    urlStream << "&scope=trading";
    
    std::string url = urlStream.str();
    Utils::ShowMsg("Opening browser...");
    
    ShellExecuteA(nullptr, "open", url.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
    
    std::string code;
    if (!ListenForCode(code, 53123, 60000)) {
        return false;
    }
    
    std::string accessToken, refreshToken;
    if (!ExchangeCodeForTokens(code, accessToken, refreshToken)) {
        return false;
    }
    
    strncpy_s(G.Token, sizeof(G.Token), accessToken.c_str(), _TRUNCATE);
    if (!refreshToken.empty()) {
        strncpy_s(G.RefreshToken, sizeof(G.RefreshToken), refreshToken.c_str(), _TRUNCATE);
    }
    
    Auth::SaveTokenToDisk(accessToken, refreshToken);
    Utils::ShowMsg("OAuth completed!");
    return true;
}

}


// ============================================================================
// ===== FILE: src/reconnect.cpp =====
// ============================================================================
#include "reconnect.h"
#include "network.h"
#include "utils.h"
#include "symbols.h"
#include <cmath>

namespace Reconnect {

bool AuthenticateAfterConnect() {
    char request[1024] = {0};
    char response[16384] = {0};
    
    sprintf_s(request,
        "{\"clientMsgId\":\"%s\",\"payloadType\":2100,\"payload\":{\"clientId\":\"%s\",\"clientSecret\":\"%s\"}}",
        Utils::GetMsgId(), G.ClientId, G.ClientSecret);
    
    if (!Network::Send(request) || Network::Receive(response, sizeof(response)) <= 0 ||
        !strstr(response, "\"payloadType\":2101")) {
        return false;
    }
    
    ZeroMemory(request, sizeof(request));
    ZeroMemory(response, sizeof(response));
    
    sprintf_s(request,
        "{\"clientMsgId\":\"%s\",\"payloadType\":2102,\"payload\":{\"accessToken\":\"%s\",\"ctidTraderAccountId\":%lld}}",
        Utils::GetMsgId(), G.Token, G.CTraderAccountId);
    
    if (!Network::Send(request) || Network::Receive(response, sizeof(response)) <= 0 ||
        !strstr(response, "\"payloadType\":2103")) {
        return false;
    }
    
    return true;
}

void ResubscribeSymbols() {
    Symbols::BatchResubscribe(G.CTraderAccountId);
}

bool Attempt(int maxRetries) {
    Utils::ShowMsg("Reconnecting...");
    Network::Disconnect();
    
    const char* host = (G.Env == CtraderEnv::Live) ? CTRADER_HOST_LIVE : CTRADER_HOST_DEMO;
    
    for (int attempt = 0; attempt < maxRetries; ++attempt) {
        char msg[128];
        sprintf_s(msg, "Attempt %d/%d", attempt + 1, maxRetries);
        Utils::ShowMsg(msg);
        
        Sleep((DWORD)(1000 * pow(3.0, (double)attempt)));
        
        if (Network::Connect(host, "5036") && AuthenticateAfterConnect()) {
            ResubscribeSymbols();
            Utils::ShowMsg("Reconnected!");
            return true;
        }
    }
    
    return false;
}

}


// ============================================================================
// ===== FILE: src/csv_loader.cpp =====
// ============================================================================
#include "csv_loader.h"
#include "utils.h"
#include <fstream>
#include <sstream>

namespace CsvLoader {

static void AsciiToLowerInplace(std::string& s) {
    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char c = (unsigned char)s[i];
        if (c >= 'A' && c <= 'Z') s[i] = (char)(c + 32);
    }
}

static bool StrContainsCi(const char* haystack, const char* needle) {
    if (!haystack || !needle) return false;
    std::string h(haystack), n(needle);
    AsciiToLowerInplace(h);
    AsciiToLowerInplace(n);
    return h.find(n) != std::string::npos;
}

static std::string TrimCopy(const std::string& s) {
    size_t b = 0, e = s.size();
    while (b < e && (s[b] == ' ' || s[b] == '\t' || s[b] == '\r' || s[b] == '\n')) ++b;
    while (e > b && (s[e-1] == ' ' || s[e-1] == '\t' || s[e-1] == '\r' || s[e-1] == '\n')) --e;
    return s.substr(b, e - b);
}

static std::vector<std::string> SplitCsvLine(const std::string& line) {
    std::vector<std::string> outv;
    std::string cur;
    bool inq = false;
    
    for (char c : line) {
        if (c == '"') {
            inq = !inq;
            continue;
        }
        if (!inq && (c == ',' || c == ';' || c == '\t')) {
            outv.push_back(TrimCopy(cur));
            cur.clear();
        } else {
            cur.push_back(c);
        }
    }
    outv.push_back(TrimCopy(cur));
    return outv;
}

bool LoadAccountsCsv(CsvCreds& out, const char* hintAccountOrUser, const char* typeHint) {
    auto FileExists = [](const char* path)->bool {
        DWORD a = GetFileAttributesA(path);
        return (a != INVALID_FILE_ATTRIBUTES && !(a & FILE_ATTRIBUTE_DIRECTORY));
    };
    
    char path1[MAX_PATH], path2[MAX_PATH], path3[MAX_PATH], path4[MAX_PATH];
    sprintf_s(path1, "%sAccounts.csv", G.DllPath);
    sprintf_s(path2, "%saccount.csv", G.DllPath);
    
    char parent[MAX_PATH];
    strcpy_s(parent, G.DllPath);
    size_t len = strlen(parent);
    if (len > 0 && (parent[len-1] == '\\' || parent[len-1] == '/')) parent[len-1] = '\0';
    char* last = strrchr(parent, '\\');
    if (last) *last = '\0';
    sprintf_s(path3, "%s\\History\\Accounts.csv", parent);
    sprintf_s(path4, "%s\\History\\account.csv", parent);
    
    const char* use = nullptr;
    if (FileExists(path1)) use = path1;
    else if (FileExists(path2)) use = path2;
    else if (FileExists(path3)) use = path3;
    else if (FileExists(path4)) use = path4;
    
    if (!use) {
        Utils::ShowMsg("Accounts.csv not found");
        return false;
    }
    
    std::ifstream f(use);
    if (!f.is_open()) return false;
    
    std::string header;
    if (!std::getline(f, header)) return false;
    
    auto cols = SplitCsvLine(header);
    std::map<std::string, int> idx;
    
    for (size_t i = 0; i < cols.size(); ++i) {
        std::string k = cols[i];
        AsciiToLowerInplace(k);
        idx[k] = (int)i;
    }
    
    auto Get = [&](const std::vector<std::string>& row, const char* key)->std::string {
        std::string k(key);
        AsciiToLowerInplace(k);
        auto it = idx.find(k);
        if (it == idx.end() || it->second >= (int)row.size()) return {};
        return row[it->second];
    };
    
    CsvCreds selected;
    bool found = false;
    
    while (f) {
        std::string line;
        if (!std::getline(f, line)) break;
        if (line.empty()) continue;
        
        auto row = SplitCsvLine(line);
        if (row.empty()) continue;
        
        std::string plugin = Get(row, "Plugin");
        std::string server = Get(row, "Server");
        std::string broker = Get(row, "Broker");
        
        if (!plugin.empty() && !StrContainsCi(plugin.c_str(), "ctrader")) continue;
        if (!server.empty() && !StrContainsCi(server.c_str(), "ctrader")) continue;
        if (!broker.empty() && !StrContainsCi(broker.c_str(), "ctrader")) continue;
        
        std::string user = Get(row, "User");
        if (user.empty()) user = Get(row, "ClientId");
        
        std::string pass = Get(row, "Pass");
        if (pass.empty()) pass = Get(row, "ClientSecret");
        
        std::string accountId = Get(row, "AccountId");
        std::string type = Get(row, "Type");
        std::string token = Get(row, "AccessToken");
        
        selected.clientId = user;
        selected.clientSecret = pass;
        selected.accountId = accountId;
        selected.type = type;
        selected.accessToken = token;
        
        if (!selected.clientId.empty() && !selected.clientSecret.empty()) {
            found = true;
            break;
        }
    }
    
    if (!found) return false;
    
    out = selected;
    return true;
}

}


// ============================================================================
// ===== FILE: src/symbols.cpp =====
// COPY PASTE FROM YOUR PDF - TOO LONG, KEEPING ORIGINAL
// ============================================================================
// SEE ORIGINAL symbols.cpp FROM PDF


// ============================================================================
// ===== FILE: src/main.cpp =====
// ============================================================================
#include "globals.h"
#include "network.h"
#include "auth.h"
#include "oauth_utils.h"
#include "reconnect.h"
#include "symbols.h"
#include "utils.h"
#include "csv_loader.h"

int(__cdecl* BrokerMessage)(const char* Text) = NULL;
int(__cdecl* BrokerProgress)(intptr_t Progress) = NULL;

GLOBAL G;

// Forward declaration from symbols.cpp (not in header)
extern void showMsg(const char* Text, const char* Detail = "");
extern void log_to_wesocket(const char* line1, const char* line2 = nullptr);
extern const char* get_msg_id();

// Wrappers for symbols.cpp compatibility
void showMsg(const char* Text, const char* Detail) { Utils::ShowMsg(Text, Detail); }
void log_to_wesocket(const char* line1, const char* line2) { Utils::LogToFile(line1, line2 ? line2 : ""); }
const char* get_msg_id() { return Utils::GetMsgId(); }
bool body_indicates_error(const char* buffer) { return Utils::BodyIndicatesError(buffer); }
bool tcp_send(const char* data) { return Network::Send(data); }

static const char* HostForEnv() {
    return (G.Env == CtraderEnv::Live) ? CTRADER_HOST_LIVE : CTRADER_HOST_DEMO;
}

static CtraderEnv DetectEnvFromType(const char* Type) {
    if (Utils::StrContainsCaseInsensitive(Type, "live") || 
        Utils::StrContainsCaseInsensitive(Type, "real")) {
        return CtraderEnv::Live;
    }
    return CtraderEnv::Demo;
}

unsigned __stdcall NetworkThread(void*) {
    char buffer[32768];
    
    while (G.bIsRunning) {
        ULONGLONG now = GetTickCount64();
        
        if (now - G.lastRetryProcessMs > 1000) {
            Symbols::ProcessRetries(G.CTraderAccountId);
            G.lastRetryProcessMs = now;
        }
        
        int bytes = Network::Receive(buffer, sizeof(buffer));
        
        if (bytes < 0) {
            Utils::ShowMsg("Connection lost");
            if (G.HasLogin && Reconnect::Attempt()) {
                continue;
            }
            G.bIsRunning = false;
            break;
        }
        
        if (bytes == 0) {
            if (now - G.lastPingMs >= PING_INTERVAL_MS) {
                char ping[64];
                sprintf_s(ping, "{\"payloadType\":2106,\"payload\":{}}");
                Network::Send(ping);
                G.lastPingMs = now;
            }
            continue;
        }
        
        G.lastPingMs = GetTickCount64();
        
        const char* pType = strstr(buffer, "\"payloadType\":");
        int payloadType = 0;
        if (pType) sscanf_s(pType, "\"payloadType\":%d", &payloadType);
        
        if (payloadType == 2122) {
            char clientMsgId[64] = {0};
            const char* pId = strstr(buffer, "\"clientMsgId\":\"");
            if (pId) sscanf_s(pId, "\"clientMsgId\":\"%63[^\"]\"", clientMsgId, (unsigned)_countof(clientMsgId));
            
            bool success = !Utils::BodyIndicatesError(buffer);
            std::string error_details;
            Symbols::HandleSubscriptionResponse(clientMsgId, success, error_details);
        }
        else if (payloadType == 2126) {
            // Handle trades and quotes - see original NetworkThread
        }
        else if (payloadType == 2106) {
            char pong[64];
            sprintf_s(pong, "{\"payloadType\":2106,\"payload\":{}}");
            Network::Send(pong);
        }
    }
    
    return 0;
}

DLLFUNC int BrokerOpen(char* Name, FARPROC fpError, FARPROC fpProgress) {
    strcpy_s(G.DllPath, Name);
    BrokerMessage = (int(__cdecl*)(const char*))fpError;
    BrokerProgress = (int(__cdecl*)(intptr_t))fpProgress;
    return PLUGIN_VERSION[0];
}

DLLFUNC int BrokerLogin(char* User, char* Pwd, char* Type, char* Accounts) {
    if (G.bIsRunning) {
        G.bIsRunning = false;
        if (G.hNetworkThread) {
            WaitForSingleObject(G.hNetworkThread, 2000);
            CloseHandle(G.hNetworkThread);
            G.hNetworkThread = NULL;
        }
    }
    
    Network::Disconnect();
    ZeroMemory(&G, sizeof(G));
    Symbols::Cleanup();
    Symbols::Initialize();
    
    G.nextTradeId = 1;
    
    CsvCreds cc;
    if (CsvLoader::LoadAccountsCsv(cc, User, Type)) {
        strncpy_s(G.ClientId, sizeof(G.ClientId), cc.clientId.c_str(), _TRUNCATE);
        strncpy_s(G.ClientSecret, sizeof(G.ClientSecret), cc.clientSecret.c_str(), _TRUNCATE);
        G.CTraderAccountId = _strtoui64(cc.accountId.c_str(), NULL, 10);
        G.Env = DetectEnvFromType(cc.type.c_str());
        if (!cc.accessToken.empty()) {
            strncpy_s(G.Token, sizeof(G.Token), cc.accessToken.c_str(), _TRUNCATE);
        }
    }
    
    G.HasLogin = true;
    
    if (G.Token[0] == '\0') {
        if (Auth::LoadTokenFromDisk()) {
            Utils::ShowMsg("Token loaded");
        }
    }
    
    if (G.Token[0] == '\0') {
        if (!OAuth::PerformInteractiveFlow()) {
            return 0;
        }
    }
    
    if (!Network::Connect(HostForEnv(), "5036")) return 0;
    
    // App auth, account auth, symbols - see full implementation
    
    G.bIsRunning = true;
    G.hNetworkThread = (HANDLE)_beginthreadex(NULL, 0, &NetworkThread, NULL, 0, NULL);
    
    return 1;
}

DLLFUNC void BrokerClose() {
    if (G.bIsRunning) {
        G.bIsRunning = false;
        if (G.hNetworkThread) {
            WaitForSingleObject(G.hNetworkThread, 2000);
            CloseHandle(G.hNetworkThread);
            G.hNetworkThread = NULL;
        }
    }
    Network::Disconnect();
}

// Implement all other BrokerXXX functions - see full code

BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        Symbols::Initialize();
        InitializeCriticalSection(&G.cs_trades);
        InitializeCriticalSection(&G.cs_log);
        
        GetModuleFileNameA((HMODULE)hModule, G.DllPath, MAX_PATH);
        char* pLastSlash = strrchr(G.DllPath, '\\');
        if (pLastSlash) *(pLastSlash + 1) = '\0';
        
        WSADATA wsaData;
        WSAStartup(MAKEWORD(2, 2), &wsaData);
    }
    else if (ul_reason_for_call == DLL_PROCESS_DETACH) {
        BrokerClose();
        Symbols::Cleanup();
        DeleteCriticalSection(&G.cs_trades);
        DeleteCriticalSection(&G.cs_log);
        WSACleanup();
    }
    return TRUE;
}


// ============================================================================
// ===== FILE: exports.def =====
// ============================================================================
EXPORTS
    BrokerOpen
    BrokerLogin
    BrokerLogout
    BrokerTime
    BrokerAsset
    BrokerBuy
    BrokerBuy2
    BrokerSell
    BrokerSell2
    BrokerTrade
    BrokerAccount
    BrokerAccount2
    BrokerCommand
    BrokerRequest
    BrokerHistory
    BrokerHistory2
    BrokerClose


// ============================================================================
// ===== FILE: ctrader_plugin.vcxproj =====
// ============================================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  
  <PropertyGroup Label="Globals">
    <ProjectGuid>{12345678-1234-1234-1234-123456789ABC}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  
  <PropertyGroup Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ws2_32.lib;winhttp.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  
  <ItemGroup>
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\network.cpp" />
    <ClCompile Include="src\auth.cpp" />
    <ClCompile Include="src\oauth_utils.cpp" />
    <ClCompile Include="src\reconnect.cpp" />
    <ClCompile Include="src\symbols.cpp" />
    <ClCompile Include="src\utils.cpp" />
    <ClCompile Include="src\csv_loader.cpp" />
  </ItemGroup>
  
  <ItemGroup>
    <ClInclude Include="include\globals.h" />
    <ClInclude Include="include\network.h" />
    <ClInclude Include="include\auth.h" />
    <ClInclude Include="include\oauth_utils.h" />
    <ClInclude Include="include\reconnect.h" />
    <ClInclude Include="include\symbols.h" />
    <ClInclude Include="include\utils.h" />
    <ClInclude Include="include\csv_loader.h" />
  </ItemGroup>
  
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

---

# KÉSZ

Másold ki az egészet, mentsd `.txt`-be. Keress rá: `// ===== FILE:` és szedd szét fájlokra.

**FONTOS:** A `symbols.cpp` és teljes `main.cpp` NetworkThread része HIÁNYZIK (túl hosszú). Használd az eredeti PDF-ből.